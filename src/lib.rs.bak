//
// fix width typing for TeX picture-env.
//

//
// this code does not support combinatin of UTF-8.
// you should use 'nkf' or simular programs:
//      $ nkf --ic=utf8-mac --oc=utf-8 in.txt |thisprogram > out.tex
//

use clap::{App, Arg};
use std::error::Error;
use std::fs::File;
use std::io::{self, BufRead, BufReader};

const VERSION: &str = env!("CARGO_PKG_VERSION");

#[inline]
fn git_hash() -> &'static str {
    option_env!("GIT_HASH").unwrap_or("")
}

#[inline]
fn build_date() -> &'static str {
    option_env!("BUILD_DATE").unwrap_or("")
}

fn long_version() -> String {
    let h = git_hash();
    let d = build_date();
    match (h.is_empty(), d.is_empty()) {
        (true, true) => VERSION.to_string(),
        (false, true) => format!("{VERSION} ({h})"),
        (true, false) => format!("{VERSION} [{d}]"),
        (false, false) => format!("{VERSION} ({h}) [{d}]"),
    }
}

pub const DIME_AUTO: usize = 99999;

fn dime_auto_str() -> &'static str {
    Box::leak(DIME_AUTO.to_string().into_boxed_str())
}

type MyResult<T> = Result<T, Box<dyn Error>>;

#[derive(Debug, Clone)]
struct CharSize {
    width: usize,
    height: usize,
}

impl PartialEq for CharSize {
    fn eq(&self, other: &Self) -> bool {
        self.height == other.height && self.width == other.width
    }
}

#[derive(Debug)]
pub struct Config {
    files: Vec<String>,
    csize: CharSize,
    lineheight: usize,
    outmargin: usize,
    sepmargin: usize,
    frames: usize,
    tabstop: usize,
    wchars: usize,
    basedrift_a: isize,
    gridhpitch: usize,
    gridvpitch: usize,
    abovegap: String,
    belowgap: String,
    linenumoffset: usize,
    linenumwidth: usize,
    //
    spcmarking: bool,
    grid: bool,
    numbering: bool,
    standalone: bool,
}

// --------------------------------------------------
pub fn get_args() -> MyResult<Config> {
    let long: &'static str = Box::leak(long_version().into_boxed_str());

    let matches = App::new(env!("CARGO_PKG_NAME"))
        .version(long)
        .author("Ken-ichi Chinen <k-chinen@metro-cit.ac.jp>")
        .about("generate fix width printing for LaTeX from plane text")
        .arg(
            Arg::with_name("linenumoffset")
                .short("N")
                .long("linenumoffset")
                .takes_value(true)
                .help("linenumber offset")
                .default_value("0"),
        )
        .arg(
            Arg::with_name("linenumwidth")
                .short("W")
                .long("linenumwidth")
                .takes_value(true)
                .help("linenumber width")
                .default_value(dime_auto_str()),
        )
        .arg(
            Arg::with_name("abovegap")
                .short("A")
                .long("above")
                .takes_value(true)
                .help("above gap like \".5em\"")
                .default_value(""),
        )
        .arg(
            Arg::with_name("belowgap")
                .short("B")
                .long("below")
                .takes_value(true)
                .help("below gap like \"12pt\"")
                .default_value(""),
        )
        .arg(
            Arg::with_name("tabstop")
                .short("t")
                .long("tabstop")
                .takes_value(true)
                .help("tabstop")
                .default_value("8"),
        )
        .arg(
            Arg::with_name("gridhpitch")
                .short("G")
                .long("gridhpitch")
                .takes_value(true)
                .help("grid pitch in horizontal")
                .default_value("5"),
        )
        .arg(
            Arg::with_name("gridvpitch")
                .short("Z")
                .long("gridvpitch")
                .takes_value(true)
                .help("grid pitch in vertical")
                .default_value("5"),
        )
        .arg(
            Arg::with_name("wchars")
                .short("w")
                .long("wchars")
                .takes_value(true)
                .help("width of line")
                .default_value("64"),
        )
        .arg(
            Arg::with_name("basedrift_a")
                .short("b")
                .long("basedrift_a")
                .takes_value(true)
                .help("basedrift for ASCII")
                .default_value("0"),
        )
        .arg(
            Arg::with_name("outmargin")
                .short("m")
                .long("outmargin")
                .takes_value(true)
                .help("out margin width")
                .default_value("5"),
        )
        .arg(
            Arg::with_name("sepmargin")
                .short("s")
                .long("sepmargin")
                .takes_value(true)
                .help("sep margin width")
                .default_value("2"),
        )
        .arg(
            Arg::with_name("lineheight")
                .short("H")
                .long("lineheight")
                .takes_value(true)
                .help("lineheight; if not specified csize *1.2")
                .default_value(dime_auto_str()),
        )
        .arg(
            Arg::with_name("csize")
                .short("c")
                .long("csize")
                .takes_value(true)
                .help("charctor size like \"17\" or \"20x10\" in pt")
                .default_value("10x5"),
        )
        .arg(
            Arg::with_name("grid")
                .short("g")
                .long("grid")
                .takes_value(false)
                .help("grid"),
        )
        .arg(
            Arg::with_name("spcmarking")
                .short("u")
                .long("spcmakring")
                .takes_value(false)
                .help("Space marking"),
        )
        .arg(
            Arg::with_name("numbering")
                .short("n")
                .long("numbering")
                .takes_value(false)
                .help("Numbering"),
        )
        .arg(
            Arg::with_name("standalone")
                .short("S")
                .long("standalone")
                .takes_value(false)
                .help("add preamble and begin/end document"),
        )
        .arg(
            Arg::with_name("frames")
                .short("f")
                .long("frames")
                .takes_value(true)
                .help("set of frames")
                .default_value("15"),
        )
        .arg(
            Arg::with_name("files")
                .value_name("FILE")
                .help("Input file(s)")
                .multiple(true)
                .default_value("-"),
        )
        .get_matches();

    if matches.is_present("version") {
        // clap が自動で処理します
    }

    let csize = matches
        .value_of("csize")
        .map(parse_2d_int)
        .transpose()
        .map_err(|e| format!("illegal csize -- {}", e))?;

    let mut lineheight = matches
        .value_of("lineheight")
        .map(parse_positive_int)
        .transpose()
        .map_err(|e| format!("illegal lineheight -- {}", e))?;

    let linenumoffset = matches
        .value_of("linenumoffset")
        .map(parse_uint)
        .transpose()
        .map_err(|e| format!("illegal linenumoffset -- {}", e))?;

    let linenumwidth = matches
        .value_of("linenumwidth")
        .map(parse_uint)
        .transpose()
        .map_err(|e| format!("illegal linenumwidth -- {}", e))?;

    let tabstop = matches
        .value_of("tabstop")
        .map(parse_positive_int)
        .transpose()
        .map_err(|e| format!("illegal tabstop -- {}", e))?;

    let wchars = matches
        .value_of("wchars")
        .map(parse_positive_int)
        .transpose()
        .map_err(|e| format!("illegal wchars -- {}", e))?;

    let basedrift_a = matches
        .value_of("basedrift_a")
        .map(parse_int)
        .transpose()
        .map_err(|e| format!("illegal basedrift_a  -- {}", e))?;

    let outmargin = matches
        .value_of("outmargin")
        .map(parse_positive_int)
        .transpose()
        .map_err(|e| format!("illegal outmargin width -- {}", e))?;

    let sepmargin = matches
        .value_of("sepmargin")
        .map(parse_positive_int)
        .transpose()
        .map_err(|e| format!("illegal sepmargin width -- {}", e))?;

    let gridvpitch = matches
        .value_of("gridvpitch")
        .map(parse_positive_int)
        .transpose()
        .map_err(|e| format!("illegal grid v pitch -- {}", e))?;

    let gridhpitch = matches
        .value_of("gridhpitch")
        .map(parse_positive_int)
        .transpose()
        .map_err(|e| format!("illegal grid h pitch -- {}", e))?;

    let frames = matches
        .value_of("frames")
        .map(parse_positive_int)
        .transpose()
        .map_err(|e| format!("illegal frame -- {}", e))?;

    // not specified, set automatically csize.height * 1.2
    if lineheight == Some(DIME_AUTO) {
        lineheight = Some((csize.clone().unwrap().height * 12) / 10);
    }
    if linenumwidth == Some(DIME_AUTO) {
        eprintln!("auto linenumwidth");
        //        linenumwidth = Some((csize.clone().unwrap().height*12)/10);
    }

    Ok(Config {
        files: matches.values_of_lossy("files").unwrap(),
        csize: csize.unwrap(),
        lineheight: lineheight.unwrap(),
        outmargin: outmargin.unwrap(),
        sepmargin: sepmargin.unwrap(),
        tabstop: tabstop.unwrap(),
        wchars: wchars.unwrap(),
        basedrift_a: basedrift_a.unwrap() as isize,
        frames: frames.unwrap(),
        gridhpitch: gridhpitch.unwrap(),
        gridvpitch: gridvpitch.unwrap(),
        abovegap: matches.value_of("abovegap").unwrap().to_string(),
        belowgap: matches.value_of("belowgap").unwrap().to_string(),
        linenumoffset: linenumoffset.unwrap(),
        linenumwidth: linenumwidth.unwrap(),
        grid: matches.is_present("grid"),
        spcmarking: matches.is_present("spcmarking"),
        numbering: matches.is_present("numbering"),
        standalone: matches.is_present("standalone"),
    })
}

fn fwtype(
    fp: &mut dyn BufRead,
    csize: &CharSize,
    lineheight: usize,
    outmargin: usize,
    sepmargin: usize,
    frames: usize,
    tabstop: usize,
    wchars: usize,
    basedrift_a: isize,
    gridhpitch: usize,
    gridvpitch: usize,
    grid: bool,
    dospcmarking: bool,
    donumbering: bool,
    abovegap: String,
    belowgap: String,
    linenumoffset: usize,
    linenumwidth: usize,
) {
    let nchars;
    let mut linec;
    let mut rowc;
    let mut maxline = 0;
    let mut maxchars = 0;
    let mut cont: Vec<String> = vec![];

    //  let cmdchars = r"#$%&^_{}\\|~";
    let cmdchars = "#$%&^_{}\\~";

    let mut num_overrun = 0;

    eprintln!(
        "numbering {} width {} offset {}",
        donumbering, linenumwidth, linenumoffset
    );

    linec = 0;
    rowc = 0;
    for (line_num, line_result) in fp.lines().enumerate() {
        let line = line_result.unwrap();

        linec = linec + 1;
        rowc = rowc + 1;

        let mut x = 0;
        //        for ch in line.chars() {
        let mut ch: char;
        let mut p = 0;
        loop {
            if line.len() <= 0 {
                break;
            }

            if let Some(foo) = line[p..].chars().next() {
                ch = foo;
                p += ch.len_utf8();
            } else {
                break;
            }

            if ch.is_ascii() {
                // tabstop
                if ch == '\t' {
                    x = ((x) / tabstop) * tabstop + tabstop;
                } else if ch == '\x1d' {
                    if line.len() <= 0 {
                        break;
                    }
                    if let Some(label) = line[p..].chars().next() {
                        p += label.len_utf8();
                        x = x + 3;
                    }
                } else {
                    x = x + 1;
                }
            } else {
                x = x + 2;
            }
        }

        let linelen = x;

        if linelen >= (wchars - 1) {
            let e = (linelen + wchars - 1) / wchars;
            /*
                        eprintln!("\t line_num {} {} linelen {} wchars {} -> e {}",
                            line_num, line_num+1, linelen, wchars, e);
            */
            /*
                        let k = linelen / wchars;
                        eprintln!("\t line_num {} {} linelen {} wchars {} -> k {} e {}",
                            line_num, line_num+1, linelen, wchars, k, e);
            */

            num_overrun = num_overrun + e;
            rowc = rowc + (e - 1);
            maxchars = wchars;
        } else {
            if linelen > maxchars {
                maxchars = linelen;
            }
        }

        if line_num > maxline {
            maxline = line_num;
        }

        cont.push(line);
    }
    nchars = maxchars;

    let ndigits: usize;
    if linenumwidth == DIME_AUTO {
        ndigits = if rowc <= 0 { 1 } else { rowc.ilog10() + 1 } as usize;
    } else {
        ndigits = linenumwidth;
    }

    eprintln!(
        "csize {}x{} lineheight {}",
        csize.width, csize.height, lineheight
    );
    eprintln!(
        "nchars {} linec {} rowc {} num_overrun {} basedrift_a {} ndigts {}",
        nchars, linec, rowc, num_overrun, basedrift_a, ndigits
    );
    /*
     */

    let numwid = if donumbering {
        csize.width * ndigits
    } else {
        0
    };
    let txoffset: usize = if donumbering {
        outmargin + numwid + sepmargin
    } else {
        0
    };
    let txwidth: usize = outmargin + nchars * csize.width + outmargin;
    let cvwidth: usize = txoffset + txwidth;
    let cvheight: usize = rowc * lineheight + outmargin * 2;

    let mut x;
    let mut y;
    let mut c;
    let mut q;
    let mut rinline;

    println!("");

    if abovegap == "" {
    } else {
        println!("\\vspace*{{{}}} % above", abovegap);
    }

    println!("\\noindent%");
    println!("{{%");

    println!("\\fboxsep=-.5pt%");
    println!("\\setlength{{\\unitlength}}{{1pt}}%");
    //    println!("\\tt%");
    println!("\\ttfamily\\gtfamily%");
    println!("% csize w,h={}, {}", csize.width, csize.height);
    println!(
        "\\fontsize{{{}pt}}{{{}pt}}\\selectfont%",
        csize.height, csize.height
    );
    println!(
        "\\def\\numfont{{\\fontsize{{{}pt}}{{{}pt}}\\selectfont}}%",
        (2 * csize.height / 3),
        (2 * csize.height / 3)
    );
    /*
        println!("\\def\\spcmark{{\\fontsize{{{}pt}}{{{}pt}}\\selectfont$\\diamond$}}%",
            (2*csize.height/3), (2*csize.height/3) );
    */
    println!(
        "\\def\\spcmark{{\\fontsize{{{}pt}}{{{}pt}}\\selectfont$\\triangle$}}%",
        (2 * csize.height / 3),
        (2 * csize.height / 3)
    );

    println!("\\def\\VV{{\\vrule width 0pt height 0.90em depth .25em}}%");
    println!(
        "\\def\\FA#1#2#3{{\\put(#1,#2){{\\makebox({},{}){{\\VV\\mbox{{#3}}}}}}}}%",
        csize.width, csize.height
    );
    println!(
        "\\def\\FX#1#2#3{{\\put(#1,#2){{\\makebox({},{}){{\\VV\\mbox{{#3}}}}}}}}%",
        csize.width, csize.height
    );
    println!("\\begin{{picture}}({},{})", cvwidth, cvheight);

    println!("% frame");

    println!("\\thicklines");

    if donumbering {
        /*
                println!(" \\put(0,0){{\\circle*{{3}}}}");
                println!(" \\put({},0){{\\circle*{{3}}}}", outmargin);
                println!(" \\put({},0){{\\circle*{{3}}}}", outmargin+numwid);
                println!(" \\put({},0){{\\circle*{{3}}}}", outmargin+numwid+sepmargin);
                //
                for i in 0..=ndigits {
                    println!(" \\put({},0){{\\line(0,1){{5}}}}",
                        outmargin+i*csize.width );
                }
        */
    }

    if frames == 0xf {
        println!(
            " \\put({},0){{\\framebox({},{}){{}}}}",
            txoffset, txwidth, cvheight
        );
    } else {
        if (frames & 0x01) > 0 {
            println!(" \\put({},0){{\\line(0,1){{{}}}}}", txoffset, cvheight);
        }
        if (frames & 0x08) > 0 {
            println!(" \\put({},0){{\\line(1,0){{{}}}}}", txoffset, txwidth);
        }
        if (frames & 0x02) > 0 {
            println!(
                " \\put({},{}){{\\line(-1,0){{{}}}}}",
                txoffset + txwidth,
                cvheight,
                txwidth
            );
        }
        if (frames & 0x04) > 0 {
            println!(
                " \\put({},{}){{\\line(0,-1){{{}}}}}",
                txoffset + txwidth,
                cvheight,
                cvheight
            );
        }
    }

    println!("\\thinlines");

    if grid {
        println!("% grid");
        println!("\\linethickness{{0.1pt}}");

        for gx in 0..=nchars {
            if gx % gridhpitch == 0 {
                println!(
                    "  \\put({},{}){{\\line(0,1){{ {} }} }}",
                    txoffset + outmargin + gx * csize.width,
                    cvheight * 0,
                    cvheight
                );
            }
        }

        for gy in 0..=rowc {
            if gy % gridvpitch == 0 {
                println!(
                    "  \\put({},{}){{\\line(1,0){{ {} }} }}",
                    txoffset,
                    cvheight - (outmargin + gy * lineheight),
                    txwidth
                );
            }
        }

        println!("\\thinlines");
    }

    println!("% body");

    linec = 0;
    rowc = 0;
    for line0 in cont {
        let mut p: usize;
        let mut line = line0;
        let mut shifted = 0;
        rinline = 1;

        loop {
            let xcn = line.chars().count();

            /*
            eprintln!("row {} {}-{}: |{}|", rowc, linec, rinline, line);
            */
            /*
            eprintln!("line {} {}-{}: |{}|", linec, rowc, rinline, line);
            */

            /*
                        eprintln!("linec {} rowc {}; {} - {} - {}; xcn {}", linec, rowc,
                                cvheight,
                                lineheight*(rowc+1),
                                outmargin,
                                xcn);
            */

            /*
             */

            y = cvheight - lineheight * (rowc + 1) - outmargin;
            rowc = rowc + 1;

            if donumbering {
                if rinline == 1 {
                    let numstr = format!("{:>width$}", linenumoffset + linec + 1, width = ndigits);
                    c = 0;
                    for ch in numstr.chars() {
                        x = outmargin + csize.width * c;
                        if ch == ' ' {
                            //                          println!("%skip");
                            //                          println!(" \\FA{{{}}}{{{}}}{{{}}}", x, y, "-");
                        } else {
                            println!("{{\\numfont\\FA{{{}}}{{{}}}{{{}}}}}", x, y, ch);
                        }
                        c = c + 1;
                    }
                } else {
                    x = outmargin + csize.width * (ndigits - 1);
                    println!("{{\\numfont\\FA{{{}}}{{{}}}{{{}}}}}", x, y, "-");
                }
            }

            if xcn == 0 {
                /*
                eprintln!("empty line {} row {}", linec, rowc);
                */
                //              rowc = rowc + 0;
                break;
            }

            c = 0;
            q = 0;
            p = 0;
            let mut ch: char;
            loop {
                if line.len() <= 0 {
                    break;
                }
                if let Some(foo) = line[p..].chars().next() {
                    ch = foo;
                    p += ch.len_utf8();
                } else {
                    break;
                }
                let x = txoffset + outmargin + csize.width * c;

                if ch.is_ascii() {
                    if ch == ' ' {
                        // skip space
                        if dospcmarking {
                            println!(
                                " \\FA{{{}}}{{{}}}{{\\spcmark}}",
                                x,
                                (y as isize) - basedrift_a
                            );
                        }
                    } else if ch == '\t' {
                        // skip tab
                        //                  println!("% skip tab");
                        if (c + 1) % tabstop == 0 {
                        } else {
                            c = (((c) / tabstop) * tabstop + tabstop) - 1;
                        }
                    } else if ch == '\x1d' {
                        if line.len() <= 0 {
                            println!(
                                " \\FA{{{}}}{{{}}}{{{}}}",
                                x,
                                (y as isize) - basedrift_a,
                                "\\P"
                            );
                            break;
                        }
                        /*
                        eprintln!("ch |{:?}| p {}", ch, p);
                        */
                        if let Some(label) = line[p..].chars().next() {
                            p += label.len_utf8();

                            println!(
                                " \\FA{{{}}}{{{}}}{{\\fbox{{\\hbox to 2em{{\\hss\\VV{{}}{}\\hss}}}}}}",
                                x + 3 * csize.width / 2,
                                (y as isize) - basedrift_a,
                                label
                            );
                            c = c + 3;
                            q = q + 1;
                        }
                    } else {
                        let mut och: String = "".to_string();
                        if let Some(_x) = cmdchars.find(ch) {
                            if ch == '\\' {
                                och.push_str("\\textbackslash");
                            } else {
                                och.push('\\');
                                och.push(ch);
                            }
                        } else {
                            och.push(ch);
                        }
                        println!(
                            " \\FA{{{}}}{{{}}}{{{}}}",
                            x,
                            (y as isize) - basedrift_a,
                            och
                        );
                    }
                } else {
                    println!(
                        " \\FX{{{}}}{{{}}}{{{}}}",
                        x + csize.width / 2,
                        (y as isize) - basedrift_a,
                        ch
                    );
                    c = c + 1;
                }
                c = c + 1;

                q = q + 1;

                if c > wchars {
                    /*
                    eprintln!("overrun mark {}/{}", c, wchars);
                    */
                    println!("\\thicklines");
                    println!("\\linethickness{{3pt}}");
                    println!(
                        " \\put({},{}){{\\line(0,1){{ {} }}}}",
                        txoffset + txwidth,
                        y + lineheight / 8,
                        6 * lineheight / 8
                    );
                    println!("\\thinlines");
                    break;
                }
            }

            /*
            eprintln!("loop end linec {} rowc {}; xcn {} c {} wchars {}; shifted {}",
                linec, rowc, xcn, c, wchars, shifted);
            */

            if c >= wchars {
                /*
                eprintln!("skip q {}; xcn {} c {} wchars {}; shifted {}",
                    q, xcn, c, wchars, shifted);
                eprintln!("skip before |{}|", line);
                */
                line = line.chars().skip(q).collect();
                shifted = shifted + q;
                /*
                eprintln!("skip after  |{}| shifted {}", line, shifted);
                */

                let xcn = line.chars().count();
                if xcn == 0 {
                    break;
                }
            } else {
                break;
            }

            rinline = rinline + 1;
        }

        linec = linec + 1;

        //let new_s: String = s.chars().skip(n).collect();
    }

    println!("\\end{{picture}}");
    println!("}}");

    if belowgap == "" {
    } else {
        println!("\\vspace*{{{}}} % below", belowgap);
    }

    println!("");
}

pub fn run(config: Config) -> MyResult<()> {
    let _num_files = config.files.len();

    //  dbg!(&config);

    if config.standalone {
        println!("\\documentclass{{article}} %%% fwtype-opt");
        println!("\\begin{{document}} %%% fwtypw-opt");
        println!("\\par %%% fwtypw-opt");
    }

    for (_file_num, filename) in config.files.iter().enumerate() {
        match open(filename) {
            Err(err) => eprintln!("{}: {}", filename, err),
            Ok(mut file) => {
                fwtype(
                    &mut file,
                    &config.csize,
                    config.lineheight,
                    config.outmargin,
                    config.sepmargin,
                    config.frames,
                    config.tabstop,
                    config.wchars,
                    config.basedrift_a,
                    config.gridhpitch,
                    config.gridvpitch,
                    config.grid,
                    config.spcmarking,
                    config.numbering,
                    config.abovegap.clone(),
                    config.belowgap.clone(),
                    config.linenumoffset,
                    config.linenumwidth,
                );
            }
        }
    }

    if config.standalone {
        println!("\\end{{document}} %%% fwtypw-opt");
    }

    Ok(())
}

// --------------------------------------------------
fn open(filename: &str) -> MyResult<Box<dyn BufRead>> {
    match filename {
        "-" => Ok(Box::new(BufReader::new(io::stdin()))),
        _ => Ok(Box::new(BufReader::new(File::open(filename)?))),
    }
}

// --------------------------------------------------
fn parse_2d_int(val: &str) -> MyResult<CharSize> {
    let mut h: usize = 10;
    let mut w: usize = 5;
    let pat: Vec<String> = val.split("x").map(str::to_string).collect();

    match pat.len() {
        0 => {
            panic!();
        }
        1 => {
            h = pat[0].parse().unwrap();
            w = h / 2;
        }
        2 => {
            h = pat[0].parse().unwrap();
            w = pat[1].parse().unwrap();
        }
        _ => {}
    }

    Ok(CharSize {
        width: w,
        height: h,
    })
}

// --------------------------------------------------
fn parse_positive_int(val: &str) -> MyResult<usize> {
    match val.parse() {
        Ok(n) if n > 0 => Ok(n),
        _ => Err(From::from(val)),
    }
}

// --------------------------------------------------
fn parse_int(val: &str) -> MyResult<isize> {
    match val.parse() {
        Ok(n) => Ok(n),
        _ => Err(From::from(val)),
    }
}

// --------------------------------------------------
fn parse_uint(val: &str) -> MyResult<usize> {
    match val.parse() {
        Ok(n) => Ok(n),
        _ => Err(From::from(val)),
    }
}

// --------------------------------------------------
#[test]
fn test_parse_int() {
    // -3 is an OK integer
    let res = parse_int("-3");
    assert!(res.is_ok());
    assert_eq!(res.unwrap(), -3);

    // 3 is an OK integer
    let res = parse_int("3");
    assert!(res.is_ok());
    assert_eq!(res.unwrap(), 3);

    // Any string is an error
    let res = parse_int("foo");
    assert!(res.is_err());
    assert_eq!(res.unwrap_err().to_string(), "foo".to_string());

    /*
        // A zero is an error
        let res = parse_int("0");
        assert!(res.is_err());
        assert_eq!(res.unwrap_err().to_string(), "0".to_string());
    */
}

#[test]
fn test_parse_positive_int() {
    // 3 is an OK integer
    let res = parse_positive_int("3");
    assert!(res.is_ok());
    assert_eq!(res.unwrap(), 3);

    // Any string is an error
    let res = parse_positive_int("foo");
    assert!(res.is_err());
    assert_eq!(res.unwrap_err().to_string(), "foo".to_string());

    // A zero is an error
    let res = parse_positive_int("0");
    assert!(res.is_err());
    assert_eq!(res.unwrap_err().to_string(), "0".to_string());
}

#[test]
fn test_parse_2d_int() {
    // 3 is an OK integer
    let res = parse_2d_int("8");
    assert!(res.is_ok());
    assert_eq!(
        res.unwrap(),
        CharSize {
            height: 8,
            width: 4
        }
    );

    // 12x6 is an OK integer
    let res = parse_2d_int("12x6");
    assert!(res.is_ok());
    assert_eq!(
        res.unwrap(),
        CharSize {
            height: 12,
            width: 6
        }
    );
}
